;;; compiler.scm -- Guile-SMC state machine compiler.

;; Copyright (C) 2021 Artyom V. Poptsov <poptsov.artyom@gmail.com>
;;
;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; The program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with the program.  If not, see <http://www.gnu.org/licenses/>.


;;; Commentary:

;; The compiler produces a Scheme code from a <fsm> instance.


;;; Code:

(define-module (smc compiler)
  #:use-module (oop goops)
  #:use-module (ice-9 pretty-print)
  #:use-module (smc core log)
  #:use-module (smc core state)
  #:use-module (smc core set)
  #:use-module (smc version)
  #:use-module (smc fsm)
  #:use-module (smc puml)
  #:export (fsm-compile
            %write-module
            %write-transition-table))



;; Write a header commentary to a @var{port}.
(define (%write-header port)
  (format port ";;; Generated by Guile-SMC ~a~%" (smc-version/string))
  (format port ";;; <https://github.com/artyom-poptsov/guile-smc>~%~%"))

;; Write a @code{define-module} part to a @var{port}. @var{class-name} is used
;; to export a FSM class in the @code{#:export} part. @var{extra-modules}
;; allow to specify a list of extra modules that required for the output FSM
;; to work.
(define (%write-module module extra-modules class-name port)
  (let loop ((lst `(define-module ,module
                     #:use-module (oop goops)
                     #:use-module (smc fsm)))
             (em  extra-modules))
    (if (null? em)
        (begin
          (pretty-print (append lst `(#:export (,class-name)))
                        port)
          (newline port))
        (loop (append lst `(#:use-module ,(car em)))
              (cdr em)))))

;; Write 'use-modules' section to the @var{port}.
(define (%write-use-modules extra-modules port)
  (let loop ((lst `(use-modules (smc fsm) (oop goops)))
             (em  extra-modules))
    (if (null? em)
        (begin
          (display lst port)
          (newline port))
        (loop (append lst (list (car em)))
              (cdr em)))))

;; This procedure serializes a transition @var{table}. It returns the
;; transition table as a list.
(define-method (%serialize-transition-table (table <list>))
  (map (lambda (tr)
         (map (lambda (e)
                (cond
                 ((procedure? e)
                  (list 'unquote (procedure-name e)))
                 ((state? e)
                  (state-name e))
                 (else
                  e)))
              tr))
       table))

;; Write a @var{fsm} transition table to a @var{port}.
(define-method (%write-transition-table (fsm <fsm>) (port <port>))
  (let ((table (fsm-transition-table fsm)))
    (pretty-print
     `(define %transition-table
        ,(list 'quasiquote
               (map (lambda (state)
                      (let* ((name        (state:name        state))
                             (description (state:description state))
                             (transitions (state:transitions state)))
                        `((name        . ,name)
                          (description . ,description)
                          (transitions
                           ,@(%serialize-transition-table transitions)))))
                    (hash-table->transition-list table))))
     port)))



(define* (fsm-compile fsm
                      #:key
                      (fsm-name 'custom-fsm)
                      (fsm-module    #f)
                      (extra-modules '())
                      (output-port (current-output-port)))

  (when (and (fsm-event-source fsm)
             (not (procedure-name (fsm-event-source fsm))))
    (let ((error-message
           "Cannot compile the FSM as the event source is set to an anonymous procedure"))
      (log-error "~a: ~a" error-message fsm)
      (error error-message fsm)))

  (%write-header output-port)

  (when (fsm-parent fsm)
    (display ";;; This finite-state machine is produced by:\n" output-port)
    (for-each (lambda (line) (format output-port ";;;   ~a~%" line))
              (string-split (fsm-description (fsm-parent fsm)) #\newline))
    (display ";;;\n" output-port)
    (fsm-pretty-print-statistics (fsm-parent fsm) output-port)
    (display ";;;\n" output-port)
    (puml-context-print-resolver-status (fsm-parent-context fsm)
                                        output-port)
    (newline output-port))

  (let ((class-name (string->symbol (format #f "<~a>" fsm-name))))
    (if fsm-module
        (%write-module fsm-module extra-modules class-name output-port)
        (%write-use-modules extra-modules output-port))

    (newline output-port)

    (%write-transition-table fsm output-port)

    (newline output-port)

    (pretty-print `(define-class ,class-name (<fsm>))
                  output-port)

    (newline output-port)

    (pretty-print
     `(define-method (initialize (self ,class-name) initargs)
        (next-method)
        (fsm-event-source-set! self ,(and (fsm-event-source fsm)
                                          (procedure-name (fsm-event-source fsm))))
        (fsm-transition-table-set!
         self
         (transition-list->hash-table self %transition-table))
        (fsm-current-state-set! self
                                (fsm-state self
                                           (quote ,(state-name (fsm-current-state fsm)))))))

    (newline output-port)))

;;; compiler.scm ends here.
