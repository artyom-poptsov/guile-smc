;;; compiler.scm -- Guile-SMC state machine compiler.

;; Copyright (C) 2021 Artyom V. Poptsov <poptsov.artyom@gmail.com>
;;
;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; The program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with the program.  If not, see <http://www.gnu.org/licenses/>.


;;; Commentary:

;; The compiler produces a Scheme code from a <fsm> instance.


;;; Code:

(define-module (smc compiler)
  #:use-module (oop goops)
  #:use-module (ice-9 pretty-print)
  #:use-module (smc core state)
  #:use-module (smc fsm)
  #:export (fsm-compile
            %write-module
            %write-transition-table))



(define (%write-header port)
  (display ";;; Generated by Guile-SMC\n\n" port))

(define (%write-module module extra-modules class-name port)
  (let loop ((lst `(define-module ,module
                     #:use-module (oop goops)
                     #:use-module (smc fsm)))
             (em  extra-modules))
    (if (null? em)
        (begin
          (pretty-print (append lst `(#:export (,class-name)))
                        port)
          (newline port))
        (loop (append lst `(#:use-module ,(car em)))
              (cdr em)))))

(define-method (%write-transition-table (fsm <fsm>) (port <port>))
  (let ((table (fsm-transition-table fsm)))
    (pretty-print
     `(define %transition-table
        ,(list 'quasiquote
               (map (lambda (state)
                      (if (and (> (length state) 1)
                               (string? (cadr state)))
                          (cons
                           (car state)
                           (cons (cadr state)
                                 (map (lambda (tr)
                                        (map (lambda (e)
                                               (cond
                                                ((procedure? e)
                                                 (list 'unquote (procedure-name e)))
                                                ((state? e)
                                                 (state-name e))
                                                (else
                                                 e)))
                                             tr))
                                      (caddr state))))
                          (cons
                           (car state)
                           (map (lambda (tr)
                                  (map (lambda (e)
                                         (cond
                                          ((procedure? e)
                                           (list 'unquote (procedure-name e)))
                                          ((state? e)
                                           (state-name e))
                                          (else
                                           e)))
                                       tr))
                                (cdr state)))))
                    (hash-table->transition-list table))))
     port)))



(define* (fsm-compile fsm
                      #:key
                      (fsm-name 'custom-fsm)
                      (fsm-module    #f)
                      (extra-modules '())
                      (output-port (current-output-port)))
  (%write-header output-port)
  (let ((class-name (string->symbol (format #f "<~a>" fsm-name))))
    (if fsm-module
        (%write-module fsm-module extra-modules class-name output-port)
        (display `(use-modules (smc fsm)
                               ,(quote module))
                 output-port))

    (newline output-port)

    (%write-transition-table fsm output-port)

    (newline output-port)

    (pretty-print `(define-class ,class-name (<fsm>))
                  output-port)

    (newline output-port)

    (pretty-print
     `(define-method (initialize (self ,class-name) initargs)
        (next-method)
        (fsm-transition-table-set!
         self
         (transition-list->hash-table %transition-table))
        (fsm-current-state-set! self
                                (fsm-state self
                                           (quote ,(state-name (fsm-current-state fsm)))))))

    (newline output-port)))

;;; compiler.scm ends here.
