#!@GUILE@ \
-e main
!#

(use-modules (ice-9 getopt-long)
             (ice-9 pretty-print)
             (ice-9 eval-string)
             (smc core log)
             (smc fsm)
             (smc puml)
             (smc compiler))



(define (print-compile-help)
  (display "\
Usage: smc compile [options]

The program reads a PlantUML transition diagram from the standard input.

Options:
  --help, -h        Print this message and exit.
  --print-transition-table, -p
                    Print the FSM transition table.
  --load-path, -L   Add a paths separated by a colon to load paths.
  --modules, -U     Load additional modules.
  --fsm-name, -n    Set the name for the output FSM.
  --fsm-module, -m  Set the module for the output FSM.
  --validate        Validate the output FSM and print the validation result.
  --debug           Enable the debug mode.

"))

(define (print-help-and-exit)
  (display "\
Usage: smc <command> [options]

Commands:
  compile        Compile a PlantUML state diagram to a Guile finite-state machine.
  help           Print this help message.

For each command there's '--help' option (or '-h' for short) that prints a
help message for the given command.

")
  (exit 0))

(define %option-spec
  '((help                     (single-char #\h) (value #f))
    (print-transition-table   (single-char #\p) (value #f))
    (load-path                (single-char #\L) (value #t))
    (modules                  (single-char #\U) (value #t))
    (fsm-name                 (single-char #\n) (value #t))
    (fsm-module               (single-char #\m) (value #t))
    (validate                                   (value #f))
    (debug                                      (value #f))))

(define (add-to-load-path* dirs)
  "Add all @var{dirs} to the load path list."
  (for-each (lambda (dir) (add-to-load-path dir)) dirs))

;; Core modules required to run the 'puml->fsm' converter.
(define %core-modules
  (list (resolve-module '(smc guards char))
        (resolve-module '(smc puml))
        (resolve-module '(smc fsm))))

(define (pretty-print-transition-table fsm)
  "Pretty print the transition table for a specified @var{fsm}."
  (pretty-print (hash-table->transition-list (fsm-transition-table fsm))
                #:display? #t))

(define (eval-string/quote string)
  "Quote and evaluate a @var{string}."
  (eval-string (string-append "(quote " string ")")))

(define (compile args)
  (let* ((options          (getopt-long args %option-spec))
         (extra-load-paths (option-ref options 'load-path ""))
         (debug-mode?      (option-ref options 'debug     #f)))

    (when (option-ref options 'help #f)
      (print-compile-help)
      (exit 0))

    (log-use-stderr! debug-mode?)

    (add-to-load-path* (string-split extra-load-paths #\:))

    (let* ((modules      (option-ref options 'modules #f))
           (fsm     (puml->fsm (current-input-port)
                               #:module (if modules
                                            (append %core-modules
                                                    (map resolve-module
                                                         (eval-string/quote modules)))
                                            %core-modules)
                               #:debug-mode? debug-mode?)))
      (when (option-ref options 'validate #f)
        (let ((validation-result (fsm-validate fsm)))
          (unless (null? validation-result)
            (pretty-print validation-result (current-error-port))
            (exit 1))))
      (cond
       ((option-ref options 'print-transition-table #f)
        (pretty-print-transition-table fsm))
       (else
        (let ((name   (option-ref options 'fsm-name 'custom-fsm))
              (module (option-ref options 'fsm-module #f)))
          (fsm-compile fsm
                       #:fsm-name      name
                       #:fsm-module    (and module
                                            (eval-string/quote module))
                       #:extra-modules (and modules
                                            (eval-string/quote modules)))))))))



(define (main args)

  (when (< (length args) 2)
    (print-help-and-exit))

  (let ((command (cadr args))
        (rest    (cons (car args) (cddr args))))
  (cond
   ((equal? command "compile")
    (compile rest))
   ((or (equal? command "help")
        (equal? command "-h")
        (equal? command "--help"))
    (print-help-and-exit))
   (else
    (format (current-error-port) "Unknown command: ~a~%" command)
    (print-help-and-exit)))))

;;;

;; Local Variables:
;; mode: Scheme
;; End:

;;; smc.in ends here
